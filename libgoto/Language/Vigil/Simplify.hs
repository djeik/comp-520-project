{-|
Module      : Language.Vigil.Simplify
Description : Definition of the Simplify monad
Copyright   : (c) Jacob Errington and Frederic Lafrance, 2016
License     : MIT
Maintainer  : goto@mail.jerrington.me
Stability   : experimental

Defines the @Simplify@ monad as an instance of
'Language.GoLite.Monad.Traverse.MonadTraversal'. Its purpose is to build a
Vigil syntax tree from a type-and-source annotated GoLite syntax tree.
-}

{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TypeFamilies #-}

module Language.Vigil.Simplify where

import qualified Data.Map as M
import Data.Void ( Void )

import Language.Common.Monad.Traverse
import qualified Language.Common.GlobalId as Gid
import Language.GoLite.Types ( symbolFromString )
import Language.Vigil.Syntax.Basic
import Language.Vigil.Types

-- | The @Simplify@ monad is a traversal that cannot throw errors, and uses an
-- internal state to keep track of the simplification process.
newtype Simplify a
    = Simplify { unSimplify :: Traversal SimplificationError SimplifyState a }
    deriving
        ( Functor
        , Applicative
        , Monad
        , MonadError SimplificationError
        , MonadState SimplifyState
        )

-- | Runs a computation in the Simplify monad, starting the temporary identifier
-- numbers at the supplied value. The state of the simplification is thrown away.
runSimplify :: Int -> Simplify a -> Either SimplificationError a
runSimplify n t
    = fst $ runIdentity (
        runStateT (
            runExceptT (
                runTraversal (
                    unSimplify t
                )
            )
        ) $
        SimplifyState
            { currentTemp = n
            , newDeclarations = []
            , strings = M.empty
            }
    )

instance MonadTraversal Simplify where
    type TraversalError Simplify = Void
    type TraversalState Simplify = SimplifyState
    type TraversalException Simplify = SimplificationError

    reportError = error "unimplemented"

    getErrors = error "unimplemented"

nextTempId :: Simplify Int
nextTempId = do
    num <- gets currentTemp
    modify $ \s -> s { currentTemp = num + 1 }
    pure num

-- | Generate a fresh temporary with the appropriate type.
makeTemp :: Type -> Simplify BasicIdent
makeTemp ty = do
    num <- nextTempId
    return $ Gid.GlobalId
                { Gid.gidNum = num
                , Gid.gidTy = ty
                , Gid.gidOrigName = "%tmp"
                , Gid.gidOrigin = Gid.Local
                }

-- | Create a string literal.
makeString :: String -> Simplify BasicIdent
makeString str = do
    num <- nextTempId
    let g = Gid.GlobalId
            { Gid.gidNum = num
            , Gid.gidTy = stringType
            , Gid.gidOrigName = symbolFromString $ "%strlit" ++ show num
            , Gid.gidOrigin = Gid.Local
            }
    recordString g str
    pure g

-- | Records a string in the state of the simplifier.
recordString :: GlobalId -> String -> Simplify ()
recordString g str = modify $ \s -> s { strings = M.insert g str (strings s) }

data SimplifyState
    = SimplifyState
        { currentTemp :: Int
        -- ^ Indicates the number of the next autogenerated temporary identifier.
        , newDeclarations :: [BasicIdent]
        -- ^ What temporaries have been declared so far in the current function.
        , strings :: M.Map GlobalId String
        -- ^ String literals that have been encountered.
        -- Each string literal @s@ is converted into a global variable of the
        -- form @var stringliteral_n = from_cstr(s_data)@.
        }

data SimplificationError
    = InvariantViolation String
    | UnrepresentableType String
    deriving ( Show )

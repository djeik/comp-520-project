{-|
Module      : Language.Vigil.Simplify
Description : Definition of the Simplify monad
Copyright   : (c) Jacob Errington and Frederic Lafrance, 2016
License     : MIT
Maintainer  : goto@mail.jerrington.me
Stability   : experimental

Defines the @Simplify@ monad as an instance of
'Language.GoLite.Monad.Traverse.MonadTraversal'. Its purpose is to build a
Vigil syntax tree from a type-and-source annotated GoLite syntax tree.
-}

{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}

module Language.Vigil.Simplify where

import qualified Data.Map as M
import qualified Data.Set as S
import Data.Void ( Void )

import Language.Common.Monad.Traverse
import qualified Language.Common.GlobalId as Gid
import Language.GoLite.Types ( symbolFromString, Symbol )
import Language.Vigil.Syntax.Basic
import Language.Vigil.Types
import Language.X86.Mangling

-- | The @Simplify@ monad is a traversal that cannot throw errors, and uses an
-- internal state to keep track of the simplification process.
newtype Simplify a
    = Simplify
        { unSimplify
            :: Traversal SimplificationError SimplifyState a
        }
    deriving
        ( Functor
        , Applicative
        , Monad
        , MonadError SimplificationError
        , MonadState SimplifyState
        )

-- | Runs a computation in the Simplify monad, starting the temporary identifier
-- numbers at the supplied value. The state of the simplification is thrown away.
runSimplify :: Int -> Simplify a -> Either SimplificationError (SimplifyState, a)
runSimplify n t
    = (\(e, s) -> (s,) <$> e) $ runIdentity (
        runStateT (
            runExceptT (
                runTraversal (
                    unSimplify t
                )
            )
        ) $
        SimplifyState
            { currentTemp = n
            , newDeclarations = []
            , strings = M.empty
            , inis = S.empty
            }
    )

instance MonadTraversal Simplify where
    type TraversalError Simplify = Void
    type TraversalState Simplify = SimplifyState
    type TraversalException Simplify = SimplificationError

    reportError = error "unimplemented"

    getErrors = error "unimplemented"

nextTempId :: Simplify Int
nextTempId = do
    num <- gets currentTemp
    modify $ \s -> s { currentTemp = num + 1 }
    pure num

-- | Generate a fresh temporary with the appropriate type.
makeTemp :: Type -> Simplify BasicIdent
makeTemp ty = do
    num <- nextTempId
    return $ Gid.GlobalId
        { Gid.gidNum = num
        , Gid.gidTy = ty
        , Gid.gidOrigName = "%tmp"
        , Gid.gidOrigin = Gid.Local
        }

-- | Create a string literal.
makeString :: String -> Simplify BasicIdent
makeString str = do
    num <- nextTempId
    let g = Gid.GlobalId
            { Gid.gidNum = num
            , Gid.gidTy = stringType
            , Gid.gidOrigName
                = symbolFromString $ mangleFuncName ("strlit" ++ show num)
            , Gid.gidOrigin = Gid.Local
            }
    recordString g str
    pure g

makeIdent :: Type -> Symbol () -> Simplify GlobalId
makeIdent ty sym = do
    num <- nextTempId
    pure Gid.GlobalId
        { Gid.gidNum = num
        , Gid.gidTy = ty
        , Gid.gidOrigName = sym
        , Gid.gidOrigin = Gid.Local
        }

-- | Records a string in the state of the simplifier.
recordString :: GlobalId -> String -> Simplify ()
recordString g str = modify $ \s -> s { strings = M.insert g str (strings s) }

data SimplifyState
    = SimplifyState
        { currentTemp :: Int
        -- ^ Indicates the number of the next autogenerated temporary identifier.
        , newDeclarations :: [(BasicIdent, Bool)]
        -- ^ What variables have been declared so far in the current function.
        , strings :: StringLitMap
        -- ^ String literals that have been encountered.
        -- Each string literal @s@ is converted into a global variable of the
        -- form @var stringliteral_n = from_cstr(s_data)@.
        , inis :: S.Set BasicIdent
        }

-- | The map that's used to record the global ids constructed for string
-- literals encountered in the program.
type StringLitMap = M.Map GlobalId String

data SimplificationError
    = InvariantViolation String
    | UnrepresentableType String
    deriving ( Show )

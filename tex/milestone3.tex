\documentclass[letterpaper,11pt]{article}

\usepackage[margin=2.0cm]{geometry}
\usepackage{hyperref}

\title{Milestone \#3\\Compiler design -- COMP 520}
\author{Jacob Errington \& Fr\'ed\'eric Lafrance}
\date{4 April 2016}

\begin{document}

\maketitle

\section{Overview}
We are targeting x86-64. In order to have a relatively simple code generation phase, we decided to use an intermediary representation. This language, called Vigil, has a grammar extremely similar to that of SIMPLE. For this milestone, we completed the translation from GoLite to Vigil.

The compiler itself has no new flags or commands. However, using the \texttt{pretty} command now pretty-prints the Vigil program generated from our typechecked GoLite AST.

We have made the following changes to our directory structure:
\begin{itemize}
\item \texttt{libgoto/Language/Common/}: Contains definitions common to both GoLite and Vigil.
\item \texttt{libgoto/Language/Vigil}: Vigil sub-module
	\begin{itemize}
	\item \texttt{libgoto/Language/Vigil/Simplify.hs}: Definitions for the GoLite to Vigil simplification phase
	\item \texttt{libgoto/Language/Vigil/Simplify}: Simplification code
	\item \texttt{libgoto/Language/Vigil/Syntax.hs}: Syntax definition for Vigil (i.e. grammar)
	\item \texttt{libgoto/Language/Vigil/Syntax}: Type aliases for unannotated and type-annotated Vigil syntax trees
	\end{itemize}
\item \texttt{programs/intense}: Computationally-intensive programs
\end{itemize}

\section{Design decisions}
x86 being the most ubiquitous general-purpose processor architecture in use today, it is only natural that we decide to target it. At the same time, targeting it directly from GoLite is fraught with peril. However, doing the same translation from Vigil should be relatively straightforward. Therefore, our choice of final target determined that we had to use an intermediate representation. Luckily, this class is taught by a world-renowned expert in intermediate representations.

The Vigil syntax is basically SIMPLE with a few minor modifications for the GoLite use case. Much of the simplification process involves transforming expressions into a three-address form by inserting temporary variables strategically. At the statement level, some statements are entirely discarded (e.g. empty statements and type declarations), flattened (blocks) or moved around (e.g. declarations are moved to the top of a function declaration, initializer statements of if blocks are moved just before them, additional statements for temporaries are inserted, and so on). As one would guess, this transformation is mainly done using catamorphisms over the fixed-point typechecked AST generated by the previous phase. This part is also complete; that is, we are done writing the simplification code and can output Vigil ``programs'' (these programs are not valid GoLite anymore, and cannot be compiled by anything, hence the scare quotes).

In order to make code generation in the next phase simpler, identifiers are transformed in the typecheck phase to carry type information directly, as well as a unique number. Those two additions allow us to throw away the symbol table entirely after typechecking is done.

We are therefore in a good position for our x86-64 generation. Now that we have a Vigil AST with type information, it is relatively simple to generate appropriate instructions corresponding to each syntactic element. We plan to have a phase of code generation that outputs assembly referring to virtual registers. This phase will generate the instructions in accord with the System V calling convention. Thereafter, we will run a register allocation algorithm (most likely a version of graph coloring) in order to write out actual x86-64.

We also decided upon the representation for non-basic types. Arrays and slices will be small struct-like objects carrying information on their dimensions. Structs themselves will be packed blobs, and at codegen time selector expressions will be replaced by offset arithmetic. Needless to say, managing these non-basic types will require a runtime. We plan to write this runtime in C, and link it against our compiled binary. This runtime will be in charge of calling the init function (which initializes global variables) and the main function of the GoLite program.

\section{Team organization}

\textbf{Jacob} implemented the management of global identifiers, identifier renaming and the Vigil type system.
\\
\textbf{Fr\'ed\'eric} wrote the grammar for Vigil and the simplification process.
\\
Documentation and investigation into the next phases of code generation was joint work.
\section{Resources used}
\begin{itemize}
\item \href{https://web.archive.org/web/20040812030043/www-acaps.cs.mcgill.ca/info/McCAT/McCAT.html}{McCat compiler}, for the SIMPLE grammar.
\item The \href{https://gcc.gnu.org/onlinedocs/gccint/GIMPLE.html#GIMPLE}{GIMPLE} syntax.
\item \href{https://hackage.haskell.org/package/linearscan}{\texttt{linearscan}}, a Haskell package for register allocation that we decided not to use since it does not appear to be adapted to our use case (can't differentiate between types of registers, for instance).

\end{itemize}

\end{document}
